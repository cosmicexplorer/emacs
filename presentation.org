#+TITLE:	Emacs regex compilation
#+SUBTITLE:	future directions for expressive pattern matching
#+AUTHOR:	Danny McClanahan
#+EMAIL:	dmc2@hypnicjerk.ai
#+DATE:		\today

#+DESCRIPTION:
#+KEYWORDS:

#+LANGUAGE: en

#+STARTUP: beamer
#+LaTeX_CLASS: beamer
#+LaTeX_CLASS_OPTIONS: [presentation]
#+BEAMER_THEME: Madrid

#+options: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline author:t
#+options: e:t email:nil expand-links:t f:t inline:t num:t p:nil
#+options: pri:nil prop:nil stat:t tags:t tasks:t tex:t timestamp:t
#+options: title:t toc:t todo:t |:t TeX:t LaTeX: t

#+OPTIONS: H:2
#+COLUMNS: %40ITEM %10BEAMER_env(Env) %9BEAMER_envargs(Env Args) %4BEAMER_col(Col) %10BEAMER_extra(Extra)

#+latex_header: \usepackage{twemojis}
#+latex_header: \AtBeginSection[]{\begin{frame}<beamer>\frametitle{Question}\tableofcontents[currentsection]\end{frame}}
#+latex_header: \setbeamertemplate{navigation symbols}{}

#+latex_header: \usepackage{ulem}[normalem]
#+latex_header: \renewcommand{\ULthickness}{1pt}
#+latex_header: \setlength{\ULdepth}{3pt}

#+latex_footnote_command: \footnote{%s%s}
#+latex_engraved_theme:
#+latex_compiler: pdflatex

* Who are you? Why are you here?
** Answer
*** Who are you?
/Danny McClanahan/:
- failed an independent study course in undergrad attempting to make a C compiler because (as my prof /specifically/ warned me against!) I got stuck on the parser.
- spent the next several years realizing that was actually what I should have been doing the whole time.
*** Why are you here?
I have a lot of feelings about text and I'm making it everyone else's problem!

** I \twemoji{purple_heart} ~emacs-devel~
- spent a lot of time learning much of this from ~emacs-devel~ \twemoji{nerd_face}
  - was super confused about...a lot \twemoji{sweat_smile} @@latex:\vspace{4pt}@@
- thought this would be a matter of just updating the regex engine to use modern techniques \twemoji{dna} \twemoji{atom symbol} \twemoji{medical symbol}
  - ...turns out the emacs regex engine has features that don't exist in other engines!\footnote{especially non-contiguous input, syntax-aware matching, and multibyte encoding} \twemoji{fire} \twemoji{crystal_ball} @@latex:\vspace{4pt}@@
- then i learned about other larger goals for the regex engine! \twemoji{jigsaw}
  - ...which happened to overlap a lot with my own research interests \twemoji{smiling_imp}

* What is a regular expression? When and how does implementation match formal theory?
** Answer@@latex:\footnote{This section is adapted from ``The Four Eras of Regex'' by Prof. Jamie Jennings at NCSU: \url{https://jamiejennings.com/posts/2021-09-23-dont-look-back-2/}.}@@
*** What is a regular expression?
No one's really sure!
*** When and how does implementation match formal theory?
Formal theory is mostly invoked to post-hoc justify design decisions instead of expanding its expressive power!

** How did this happen?

- Regex began as an investigation into theories of /formal languages/. @@latex:\vspace{4pt}@@
- Many features were added on to implementations to improve the practical user experience.
  - While the people adding these features were often academics, they were still very interested in building practical tools! @@latex:\vspace{4pt}@@
- This led to feature development beyond the range of formal theory (awesome!).
  - However, this also means that functionality becomes _poorly-specified_ and _implementation-defined_.
  - *Formal theory couldn't keep up!*

** The 1980s: Moonwalking and Backtracking

- 1983 :: Michael Jackson demonstrates the /moonwalk/ in the music video for "Billie Jean". @@latex:\vspace{12pt}@@
- 1986 :: /Backtracking/ is developed to simulate ~egrep~-style regular expressions.

** Backtracking Away from Formal Theory

- Backtracking ends up being a fantastic way to implement many more features!
  - ...but this is really where the break from formal theory begins. @@latex:\vspace{8pt}@@
- Perl in particular adds a whole host of functionality!
  - ...but this locks people into the specifics of perl as a language to perform many text manipulation tasks.\footnote{Much bioinformatics code still uses perl!}

** Conjecture

#+BEGIN_EXPORT latex
\begin{columns}
\column{0.95\textwidth}
\fontseries{bx}
\fontsize{18pt}{18pt}
\selectfont

Formal theory remains largely concerned with \uline{incremental improvements} to \uline{artificial benchmarks}, and much less with \textit{expanding} models to cover \uline{actual user needs}.

\end{columns}
#+END_EXPORT

** Backtracking Away from Backtracking

By the 1990s, non-backtracking engines are created.@@latex:\vspace{8pt}@@
- Current ones include ~RE2~, ~hyperscan~, and rust ~regex~.\footnote{All of which are fantastic projects I have used and built upon.}@@latex:\vspace{4pt}@@
- These make use of the earlier automaton models with linear runtimes for well-specified search tasks.
  - However, they intentionally do not cover anything beyond regular linguistic complexity.

** Complexity Theory vs Complexity Practice
@@latex:\centering@@
*So what happens if you need to do more?*

* What are regexps used for? How do Emacs users use them?
** Answer
*** What are regexps used for?
All variety of text search and parsing tasks!
*** How do Emacs users use them?
As an auxiliary form of logic, to construct the *user-level grammar for human thought* that Emacs provides: text as input and output.

** Why is Text Powerful? [1: @@latex:\uline{Text as I/O}@@]

*The reason text programming languages are successful is because text is both input (readable) and output (writable).* @@latex:\vspace{4pt}@@

- This makes text an extremely empowering and accessible framework to /navigate/ and /manipulate/ program code.

** Why is Text Powerful? [2: @@latex:\uline{Hidden Dependencies}@@]

*If you are unable to modify or deploy your code without employing an opaque external system, then you have a _hidden dependency_.* @@latex:\vspace{4pt}@@
- This opaque external system can then exert arbitrary control over your programming output.

** Why is Text Powerful? [3: @@latex:\uline{Locality}@@]
*If you cannot reproduce a system /locally/, it becomes an opaque external system.* @@latex:\vspace{4pt}@@
- e.g. GUI IDEs, cloud services, Large Language Models\footnote{all Microsoft products}

** Why is Text Powerful? [4: @@latex:\uline{What is Text?}@@]
# ** What is Text?
@@latex:\centering@@
*Text is local.*

** Emacs \twemoji{two_hearts} Text

- Emacs is a text editor which implements much of its own logic and user interface via text.
  - This is why we have elisp, a language tightly integrated with text operations from the editor. @@latex:\vspace{4pt}@@
- Because text forms UI, /parsing/ and /text search/ can be employed not just to edit code, but to construct a user interface from text input.
  - *This means that language-level mechanisms for text such as the regex engine can be extended into the user interface.*

** Who Says Text is Empowering?
Not everyone thinks text is empowering! Formal theory thinks nobody should be allowed to parse text without their tools!

*** "Don't parse HTML with regex"
"Everyone knows" not to parse HTML with regex, because regex (alone!) isn't sufficiently powerful to parse HTML. But:
- Nobody is parsing HTML with a single massive regex!
- Regex + mutable state can achieve arbitrary linguistic complexity!
- Regex search for a specific substring is much faster than parsing everything up front!

*** C Lexer Hack
Turns out those tools aren't /too/ powerful, they're actually not powerful /enough/ for practical inputs!
- This is why I got stuck on the parser in that independent study course!

** Emacs Says So!
This isn't remotely a concern for Emacs code, which regularly uses regexps to parse HTML and other programming languages! How? @@latex:\vspace{8pt}@@

- text properties :: write state to the text itself\footnote{Not unlike the tape of a turing machine!}
- syntax parsing :: regex engine is aware of this via syntax classes@@latex:\footnote{\texttt{{\textbackslash}b}, \texttt{{\textbackslash}<}, etc.: see \url{https://www.gnu.org/software/emacs/manual/html_node/elisp/Regexp-Backslash.html}.}@@
- jit-lock-mode :: use smart heuristics to only reparse what's changed@@latex:\footnote{This might just be fontification, as opposed to the work done in \texttt{syntax-ppss}.}@@

** Formal Theory: Right for the Wrong Reasons
There /are/ actually reasons to avoid using regexps to parse text! @@latex:\vspace{8pt}@@

- Regexps may have extremely non-obvious dependencies on parse context.
  - A non-greedy match may be correct when invoked in a restricted context, but may become subtly incorrect when used more generally.@@latex:\footnote{For example, \underline{\texttt{(\_<.*?):}} could match a symbol before a \underline{\texttt{:}} (like \underline{\texttt{a:}} in JavaScript), but could unintentionally match string properties like \underline{\texttt{"a:b":}} as \underline{\texttt{a:}} too!}@@ @@latex:\vspace{4pt}@@
- While text properties and buffer-local variables can retain the state necessary to parse non-regular languages, coordinating that state can be error-prone.
  - Since *there are no existing formalisms to link regex with external state*\footnote{Composing automata with other parse state is one of the subjects of my research.}, it can become extremely difficult to reproduce the precise internal state which generates a logic bug in an elisp mode.

** ~tree-sitter~

In fact, ~tree-sitter~ (since Emacs 29) was created to solve this problem /for well-specified language definitions/. @@latex:\vspace{8pt}@@

- It is a highly constraining formal tool! @@latex:\vspace{4pt}@@
- And it means you now depend on:
  - The tree-sitter grammar for your language.\footnote{obnoxious to read and write}
  - The ~tree-sitter~ library.\footnote{does not have universal uptake within distros} @@latex:\vspace{4pt}@@
- So I don't like it!
  - But for the specific task of parsing a programming language, it happens to solve a lot of other problems at once.

** So Why Use Regex?
So why are we talking about regex here? Mainly: @@latex:\vspace{4pt}@@
- Parsing programming languages is a very small subset of all text search/matching tasks!
- *Regex can be directly manipulated by the user!*

** Regex as I/O
For the interactive experiences that Emacs excels at, regex provides a powerful language /for both input and output/: @@latex:\vspace{4pt}@@
- It can be synthesized hygienically from elisp code via ~rx~, either statically at load time or dynamically at run time!
- It can be received or transformed from user input to specify powerful queries over complex data!@@latex:\footnote{See \texttt{helm-rg} and \texttt{telepathygrams} at end.}@@

** We Can Go Further...
...but this might require going beyond "regex" alone!

* What is the Emacs regex engine? How is it invoked?
** Answer\footnote{This section is an unfortunately brief walkthrough through the current regex logic.}
*** What is the Emacs regex engine?
It's a backtracking engine over multibyte codepoints, defined in ~src/regex-emacs.c~.
*** How is it invoked?
In two ways:
- over a single contiguous string input,
- over the two halves of the gap buffer.

** ~regex-emacs~ [1: @@latex:\uline{Data Layout}@@]
The compiled pattern is stored as an ~re_pattern_buffer~ struct from ~src/regex-emacs.h~. @@latex:\vspace{4pt}@@
- In particular, ~unsigned char *buffer~ holds the instructions!
- Case folding uses the char table in ~Lisp_Object translate~.

** ~regex-emacs~ [2: @@latex:\uline{Match Loop}@@]
The matching loop in ~re_match_2_internal()~ in ~src/regex-emacs.c~ goes vaguely as follows: @@latex:\vspace{4pt}@@
1. extract current and next char
  - perform multibyte varint decoding to iterate bytes
  - translate input characters via the ~translate~ case-folding char-table
2. read instruction from instruction pointer
3. big switch statement for the next instruction
  - if instruction uses syntax, read the syntax class@@latex:\footnote{\url{https://www.gnu.org/software/emacs/manual/html_node/elisp/Syntax-Class-Table.html}}@@ for the current character from the current syntax table
4. increment the instruction pointer\footnote{unless instruction was a jump}
5. if we've concluded a capture, write the end position to the C-level array ~re_nsub~

** Non-Contiguous Matching
Non-contiguous matching over the two halves of the gap buffer is supported by checking at each point whether we have progressed to the end of the first half, and then switching over to the second half. @@latex:\vspace{8pt}@@
- This allows the same code to be used for single-string search, as it simply avoids checking a NULL second pointer and only checks if we've reached the end of the first input.

** Multibyte
- It turns out this actually isn't terribly relevant to the regex engine!
  - Or at least, it doesn't really differ from "standard"@@latex:\footnote{There is no (real) standard (yet): \url{https://jamiejennings.com/posts/2021-09-07-dont-look-back-1/}.}@@ Unicode regex matching.
- Emacs reads in data from whatever encoding into multibyte,@@latex:\footnote{See \url{https://www.gnu.org/software/emacs/manual/html_node/elisp/Text-Representations.html}.}@@ and the regex engine only acts upon this normalized encoding.

* How could we do regex better in Emacs? How could Emacs do regex better than anywhere else?
** Answer\footnote{This section will describe several potential paths we might investigate, paraphrasing discussion from ~emacs-devel~.}
*** How could we do regex better in Emacs?
- introspection
- optimization
*** How could Emacs do regex better than anywhere else?
- explicit control over linguistic complexity
- libraries of composeable patterns

** Separately-Compiled Regexps
\framesubtitle{Precompile regexps to enable more powerful compilation techniques.}

- I have demonstrated this in a test branch:@@latex:\footnote{\url{https://github.com/cosmicexplorer/emacs/tree/lisp-level-regex}}@@
  - Adds native elisp objects for _regexp_ and _match data_.
  - Use ~(make-regexp "...")~ to explicitly compile a pattern string.
  - All supported\footnote{literal search methods do not use the regex engine} methods in ~search.c~ can accept either a compiled regexp or bare string. @@latex:\vspace{4pt}@@
- Artificial benchmarks@@latex:\footnote{using \texttt{test/manual/perf.el}}@@ show an improvement,\footnote{native match data object produces no improvement over consing a list} but I haven't been able to produce an apples-to-apples comparison yet.
  - Syntax highlighting would be the most appropriate, but caching these compiles currently breaks syntax parsing.\footnote{probably because of buffer-local state not available at compilation time}

** Match Over Bytes, not Chars
\framesubtitle{Compile patterns to byte-level automata, then iterate over bytes.}

- char-by-char varint decoding of multibyte/utf8 is comparatively slow
  - this is the reason go's "re2" is much much slower than the c++ re2 library
- we can do this work at compile time instead, generating a larger automaton in order to be able to think in terms of byte ranges instead
  - this is already what we do for e.g. char-folding
  - this is a necessary prerequisite for SIMD instructions

** SIMD Literal Search
\framesubtitle{Expose a SIMD literal search method for specific search tasks.}

- This is used as a "prefilter" optimization in high-performance regex engines.@@latex:\footnote{see \url{https://github.com/BurntSushi/rebar} for a fantastic discussion of techniques for regex performance}@@
- This is one of the most significant contributions to performance in these engines, skipping over much of the input before executing the byte-by-byte automaton.

** Explicit Control over Linguistic Complexity
\framesubtitle{Expose APIs which enforce a strict degree of linguistic complexity for deterministic runtime.}

- Searching for a literal string tends to be a special case, and the user should be able to make absolutely sure Emacs uses the faster algorithm, or error out if the input was invalid.\footnote{Searching for a set of literals (e.g. keywords) at once can also be done very efficiently with specific algorithms that don't use a general NFA.}
- We already duck out to a special literal matching engine in ~search.c~ if we're matching a literal against a buffer, but this requires a heuristic check for literal-only strings instead of enforcing them, resulting in difficult-to-understand performance characteristics.\footnote{This also involves an entirely separate code path which would be nice to unify.}
- Backrefs are a special case on the other end of complexity.@@latex:\footnote{These have recently been formalized: \url{https://jamiejennings.com/posts/2023-10-01-dont-look-back-3/}.}@@

** Lisp Regexp Library
\framesubtitle{Expose a lisp-level library for regexp matching.}

- The compiled form of the regexp in ~re_pattern_buffer~ can be /executed/, but not really /introspected/.
  - No form of "IR": this also contributes to the difficulty of composing patterns together.
  - This is largely because it's implemented in C.
- We have ~libgccjit~ now: @@latex:\alert{why not implement the regex engine itself in lisp?}\footnote{proposed by Pip Cet on \texttt{emacs-devel}}@@
  - Alternatively, translate the regexp into lisp which we can then JIT.
  - Integration into ~pcase~ could achieve a form of type safety along with interleaving lisp-level matching logic.
- Biggest issue for optimization: lisp code\footnote{or native modules} can't access or operate on the separate halves of the gap buffer.

* Current and Future Work
** @@latex:\texttt{helm-rg}\footnote{\url{https://github.com/cosmicexplorer/helm-rg}}@@
@@latex:\framesubtitle{A code search tool similar to \texttt{M-x grep}, using \texttt{ripgrep}\footnote{\url{https://blog.burntsushi.net/ripgrep/}}.}@@

*** A block                                           :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
- Generates regexps from input:
  - ~"a b"~ => ~"a.*b|b.*a"~.
  - Translates from PCRE to elisp regexps to highlight matches in the helm buffer.
- ~M-b~ enters "bounce mode", where matched lines can be edited directly.

*** pattern generation                                      :BMCOL:B_example:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :BEAMER_env: example
    :END:
#+ATTR_LaTeX: :width \textwidth
[[file:./emacs-helm-rg.png]]

** @@latex:\texttt{telepathygrams}\footnote{\url{https://github.com/cosmicexplorer/telepathygrams}}@@
\framesubtitle{A (WIP) code search tool that precompiles a database to execute NFAs against.}

I want to "beat ripgrep by cheating" with a precompiled index.@@latex:\footnote{Basically \texttt{etags}, but an n-gram (+ 1-gram) index vs a symbol index.} \vspace{4pt}@@
- n-gram indices have been done,@@latex:\footnote{e.g. Kythe: \url{https://kythe.io/docs/kythe-overview.html}}@@ but I don't want to just find where to /start/--I want to execute the /entire search/ against the index!
- This requires virtualizing NFA state so that it may be distributed:
  - across time :: in parallel / across machines,
  - & space :: in terms of /offsets/ vs directly against the input data.
- This may fail, but it will be fun!

** ~(point-max)~
@@latex:\framesubtitle{\twemoji{microphone} call me beep me if you wanna reach me}@@

*** ~text-mode~
- fedi :: [[https://circumstances.run/@hipsterelectron][~@hipsterelectron@circumstances.run~]]@@latex:\footnote{also (sporadically) \href{https://twitter.com/hipsterelectron}{twitter} \& \href{https://bsky.app/profile/hipsterelectron.bsky.social}{bluesky}}@@
- IRC :: ~@cosmicexplorer~ in @@latex:\texttt{\#emacsconf}\footnote{also (sporadically) elsewhere}@@ on ~irc.libera.chat~
- email :: [[mailto:dmc2@hypnicjerk.ai][~dmc2@hypnicjerk.ai~]]@@latex:\footnote{also \texttt{dmcC2@} (still deciding which poetic license to use)}@@

*** ~prog-mode~
- codeberg :: [[https://codeberg.org/cosmicexplorer][~@cosmicexplorer~]]
- github :: [[https://github.com/cosmicexplorer][~@cosmicexplorer~]]
