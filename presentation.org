#+TITLE:	Emacs regex compilation
#+SUBTITLE:	future directions for expressive pattern matching
#+AUTHOR:	Danny McClanahan
#+EMAIL:	dmc2@hypnicjerk.ai
#+DATE:		EmacsConf 2024

#+DESCRIPTION:
#+KEYWORDS:

#+LANGUAGE: en

#+STARTUP: beamer
#+LaTeX_CLASS: beamer
#+LaTeX_CLASS_OPTIONS: [presentation]
#+BEAMER_THEME: Madrid

#+options: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline author:t
#+options: e:t email:nil expand-links:t f:t inline:t num:t p:nil
#+options: pri:nil prop:nil stat:t tags:t tasks:t tex:t timestamp:t
#+options: title:t toc:t todo:t |:t TeX:t LaTeX: t

#+OPTIONS: H:2
#+COLUMNS: %40ITEM %10BEAMER_env(Env) %9BEAMER_envargs(Env Args) %4BEAMER_col(Col) %10BEAMER_extra(Extra)

#+latex_header: \usepackage{twemojis}
#+latex_header: \AtBeginSection[]{\begin{frame}<beamer>\frametitle{Question}\tableofcontents[currentsection]\end{frame}}
#+latex_header: \setbeamertemplate{navigation symbols}{}

#+latex_header: \usepackage{ulem}[normalem]
#+latex_header: \renewcommand{\ULthickness}{0.5pt}
#+latex_header: \setlength{\ULdepth}{1.3pt}

#+latex_footnote_command: \footnote{%s%s}
#+latex_engraved_theme:
#+latex_compiler: pdflatex

* Who are you? Why are you here?
** Answer
*** Who are you?
/Danny McClanahan/:
- failed an independent study course in undergrad attempting to make a C compiler because (as my prof /specifically/ warned me against!) I got stuck on the parser.
- spent the next several years realizing that was actually what I should have been doing the whole time.
*** Why are you here?
I have a lot of feelings about text and I'm making it everyone else's problem!

** I \twemoji{purple_heart} ~emacs-devel~
- spent a lot of time learning much of this from ~emacs-devel~ \twemoji{nerd_face}
  - was super confused about...a lot \twemoji{sweat_smile} @@latex:\vspace{4pt}@@
- thought this would be a matter of just updating the regex engine to use modern techniques \twemoji{dna} \twemoji{atom symbol} \twemoji{medical symbol}
  - ...turns out the emacs regex engine has features that don't exist in other engines!\footnote{especially non-contiguous input, syntax-aware matching, and multibyte encoding} \twemoji{fire} \twemoji{crystal_ball} @@latex:\vspace{4pt}@@
- then i learned about other larger goals for the regex engine! \twemoji{jigsaw}
  - ...which happened to overlap a lot with my own research interests \twemoji{smiling_imp}

* What is a regular expression? When and how does implementation match formal theory?
** Answer@@latex:\footnote{This section is adapted from ``The Four Eras of Regex'' by Prof. Jamie Jennings at NCSU: \url{https://jamiejennings.com/posts/2021-09-23-dont-look-back-2/}.}@@
*** What is a regular expression?
No one's really sure!
*** When and how does implementation match formal theory?
Formal theory is mostly invoked to post-hoc justify design decisions instead of expanding expressive power!

** How did this happen?

Regex began as an investigation into theories of /formal languages/. @@latex:\vspace{4pt}@@
- Many features were added on to implementations to improve the practical user experience.
  - While the people adding these features were often academics, they were still very interested in building practical tools!
- This led to feature development beyond the range of formal theory (awesome!).
  - However, this also means that functionality becomes _poorly-specified_ and _implementation-defined_.
  - *Formal theory couldn't keep up!*

** The 1980s: Moonwalking and Backtracking

- 1983 :: Michael Jackson demonstrates the /moonwalk/ in the music video for "Billie Jean". @@latex:\vspace{12pt}@@
- 1986 :: /Backtracking/ is developed to simulate ~egrep~-style regular expressions.

** Backtracking Away from Formal Theory

- Backtracking ends up being a fantastic way to implement many more features!
  - ...but this is really where the break from formal theory begins. @@latex:\vspace{8pt}@@
- Perl in particular adds a whole host of functionality!
  - ...but this locks people into the specifics of perl as a language to perform many text manipulation tasks.\footnote{Much bioinformatics code still uses perl!}

** Conjecture

#+BEGIN_EXPORT latex
\begin{columns}
\column{0.95\textwidth}
\fontseries{bx}
\fontsize{18pt}{18pt}
\selectfont

Formal theory remains largely concerned with \uline{incremental improvements} to \uline{artificial benchmarks}, and much less with \textit{expanding} models to cover \uline{actual user needs}.\footnote[frame]{This means they're also much slower than they could be if they \textit{listen}.}

\end{columns}
#+END_EXPORT

** Backtracking Away from Backtracking

By the 1990s, non-backtracking engines are created.@@latex:\vspace{8pt}@@
- Extant ones include @@latex:\texttt{RE2}\footnote{See \url{https://docs.rs/re2} for the only rust wrapper that will ever be blessed by its maintainer.}@@, @@latex:\texttt{hyperscan}\footnote{See \url{https://docs.rs/vectorscan-async} for the only rust wrapper that builds it for you.}@@, and rust @@latex:\texttt{regex}\footnote{Of which more will be said later.}. \vspace{4pt}@@
- These make use of the earlier automaton models with linear runtimes for well-specified search tasks.
  - However, they intentionally do not cover anything beyond regular linguistic complexity.

** Complexity Theory vs Complexity Practice
@@latex:\centering@@
*So what happens if you need to do more?*

* What are regexps used for? How do Emacs users use them?
** Answer
*** What are regexps used for?
All variety of text search and parsing tasks!
*** How do Emacs users use them?
As an auxiliary form of logic, to construct the *user-level grammar for human thought* that Emacs provides: text as input and output.

** Why is Text Powerful?
@@latex:\framesubtitle{[1: \uline{Text as I/O}]}@@

*The reason text programming languages are successful is because text is both input (readable) and output (writable).* @@latex:\vspace{4pt}@@

- This makes text an extremely empowering and accessible framework to /navigate/ and /manipulate/ program code.

** Why is Text Powerful?
@@latex:\framesubtitle{[2: \uline{Hidden Dependencies}]}@@

*If you are unable to modify or deploy your code without employing an opaque external system, then you have a _hidden dependency_.* @@latex:\vspace{4pt}@@
- This opaque external system can then exert arbitrary control over your programming output.

** Why is Text Powerful?
@@latex:\framesubtitle{[3: \uline{Locality}]}@@

*If you cannot reproduce a system /locally/, it becomes an opaque external system.* @@latex:\vspace{4pt}@@
- e.g. GUI IDEs, cloud services, Large Language Models\footnote{all Microsoft products}

** Why is Text Powerful?
@@latex:\framesubtitle{[4: \uline{What is Text?}]}@@

@@latex:\centering@@
*Text is local.*

** Emacs \twemoji{two_hearts} Text

- Emacs is a text editor which implements much of its own logic and user interface via text.
  - This is why we have elisp, a language tightly integrated with text operations from the editor. @@latex:\vspace{4pt}@@
- Because text forms UI, /parsing/ and /text search/ can be employed not just to edit code, but to construct a user interface from text input.
  - *This means that language-level mechanisms for text such as the regex engine can be extended into the user interface.*

** Who Says Text is Empowering?
Not everyone thinks text is empowering! Formal theory thinks nobody should be allowed to parse text without their tools!

*** "Don't parse HTML with regex"
"Everyone knows" not to parse HTML with regex, because regex (alone!) isn't sufficiently powerful to parse HTML. But:
- Nobody is parsing HTML with a single massive regex!
- Regex + mutable state can achieve arbitrary linguistic complexity!
- Regex search for a specific substring is much faster than parsing everything up front!

*** C Lexer Hack
Turns out those tools aren't /too/ powerful, they're actually not powerful /enough/ for practical inputs!
- This is why I got stuck on the parser in that independent study course!

** Emacs Says So!
This isn't remotely a concern for Emacs code, which regularly uses regexps to parse HTML and other programming languages! How? @@latex:\vspace{8pt}@@

- text properties :: write state to the text itself\footnote{Not unlike the tape of a turing machine!}
- syntax parsing :: regex engine is aware of this via syntax classes@@latex:\footnote{\texttt{{\textbackslash}b}, \texttt{{\textbackslash}<}, etc.: see \url{https://www.gnu.org/software/emacs/manual/html_node/elisp/Regexp-Backslash.html}.}@@
- jit-lock-mode :: use smart heuristics to only reparse what's changed@@latex:\footnote{This might just be fontification, as opposed to the work done in \texttt{syntax-ppss}.}@@

** Formal Theory: Right for the Wrong Reasons
There /are/ actually reasons to avoid using regexps to parse text! @@latex:\vspace{8pt}@@

- Regexps may have extremely non-obvious dependencies on parse context.
  - A non-greedy match may be correct when invoked in a restricted context, but may become subtly incorrect when used more generally.@@latex:\footnote{For example, \underline{\texttt{(\_<.*?):}} could match a symbol before a \underline{\texttt{:}} (like \underline{\texttt{a:}} in JavaScript), but could unintentionally match string properties like \underline{\texttt{"a:b":}} as \underline{\texttt{a:}} too!}@@ @@latex:\vspace{4pt}@@
- While text properties and buffer-local variables can retain the state necessary to parse non-regular languages, coordinating that state can be error-prone.
  - Since *there are no existing formalisms to link regex with external state*\footnote{Composing automata with other parse state is one of the subjects of my research.}, it can become extremely difficult to reproduce the precise internal state which generates a logic bug in an elisp mode.

** ~tree-sitter~

In fact, ~tree-sitter~ (since Emacs 29) was created to solve this problem /for well-specified language definitions/. @@latex:\vspace{8pt}@@

- It is a highly constraining formal tool! @@latex:\vspace{4pt}@@
- And it means you now depend on:
  - The tree-sitter grammar for your language.\footnote{obnoxious to read and write}
  - The ~tree-sitter~ library.\footnote{does not have universal uptake within distros} @@latex:\vspace{4pt}@@
- So I don't like it!
  - But for the specific task of parsing a programming language, it happens to solve a lot of other problems at once.

** So Why Use Regex?
So why are we talking about regex here? Mainly: @@latex:\vspace{4pt}@@
- Parsing programming languages is a very small subset of all text search/matching tasks!
- *Regex can be directly manipulated by the user!*

** Regex as I/O
For the interactive experiences that Emacs excels at, regex provides a powerful language /for both input and output/: @@latex:\vspace{4pt}@@
- It can be synthesized hygienically from elisp code via ~rx~, either statically at load time or dynamically at run time!
- It can be received or transformed from user input to specify powerful queries over complex data!@@latex:\footnote{See \texttt{helm-rg} and \texttt{telepathygrams} at end.}@@

** We Can Go Further...
@@latex:\centering@@
*...but this might require going beyond "regex" alone!*

* What is the Emacs regex engine? How is it invoked?
** Answer\footnote{This section is an unfortunately brief walkthrough through the current regex logic.}
*** What is the Emacs regex engine?
It's a backtracking engine over multibyte codepoints, defined in ~src/regex-emacs.c~.
*** How is it invoked?
In two ways:
- over a single contiguous string input,
- over the two halves of the gap buffer.

** ~regex-emacs~
@@latex:\framesubtitle{[1: \uline{Data Layout}]}@@

The compiled pattern is stored as an ~re_pattern_buffer~ struct from ~src/regex-emacs.h~. @@latex:\vspace{4pt}@@
- In particular, ~unsigned char *buffer~ holds the instructions!
- Case folding uses the char table in ~Lisp_Object translate~.

** ~regex-emacs~
@@latex:\framesubtitle{[2: \uline{Match Loop}]}@@

The matching loop in ~re_match_2_internal()~ in ~src/regex-emacs.c~ goes vaguely as follows: @@latex:\vspace{4pt}@@
1. extract current and next char
  - perform multibyte varint decoding to iterate bytes
  - translate input characters via the ~translate~ case-folding char-table
2. read instruction from instruction pointer
3. big switch statement for the next instruction
  - if instruction uses syntax, read the syntax class@@latex:\footnote{\url{https://www.gnu.org/software/emacs/manual/html_node/elisp/Syntax-Class-Table.html}}@@ for the current character from the current syntax table
4. increment the instruction pointer\footnote{unless instruction was a jump}
5. if we've concluded a capture, write the end position to the C-level array ~re_nsub~

** Non-Contiguous Matching
Non-contiguous matching over the two halves of the gap buffer is supported by checking at each point whether we have progressed to the end of the first half, and then switching over to the second half. @@latex:\vspace{8pt}@@
- This allows the same code to be used for single-string search, as it simply avoids checking a NULL second pointer and only checks if we've reached the end of the first input.

** Multibyte
- It turns out this actually isn't terribly relevant to the regex engine!
  - Or at least, it doesn't really differ from "standard"@@latex:\footnote{There is no (real) standard (yet): \url{https://jamiejennings.com/posts/2021-09-07-dont-look-back-1/}.}@@ Unicode regex matching.
- Emacs reads in data from whatever encoding into multibyte,@@latex:\footnote{See \url{https://www.gnu.org/software/emacs/manual/html_node/elisp/Text-Representations.html}.}@@ and the regex engine only acts upon this normalized encoding.

** Is that all?
@@latex:\centering@@

*How much time\footnote{and space} do you have?*

* How could we do regex better in Emacs? How could Emacs do regex better than anywhere else?
** Answer\footnote{This section will describe several potential paths we might investigate, paraphrasing discussion from ~emacs-devel~.}
*** How could we do regex better in Emacs?
- introspection
- optimization
*** How could Emacs do regex better than anywhere else?
- explicit control over linguistic complexity
- libraries of composeable patterns

** Separately-Compiled Regexps
\framesubtitle{Precompile regexps to enable more powerful compilation techniques.}

- Problem :: Emacs currently uses a fixed-size global compile cache.
- Solution :: Create native elisp objects for _regexps_ and _match data_.@@latex:\footnote{I have demonstrated this in a test branch: \url{https://github.com/cosmicexplorer/emacs/tree/lisp-level-regex}.}@@
  - Use ~(make-regexp "...")~ to explicitly compile a pattern string.
  - All supported\footnote{Literal search methods do not use the regex engine.} methods in ~search.c~ can accept either a compiled regexp or bare string.

** Separately-Compiled Regexps
\framesubtitle{Precompile regexps to enable more powerful compilation techniques.}

- Results :: *Artificial benchmarks@@latex:\footnote{Using \texttt{test/manual/perf.el}.}@@ show an improvement!\footnote{Using the native match data object produces no improvement over consing a list.}*
  - ...but I haven't been able to produce an apples-to-apples comparison yet.
  - Syntax highlighting would be the most appropriate, but caching these compiles currently breaks fontification.\footnote{Current guess is that it relies on buffer-local state not available when precompiled.}

** Match Over Bytes, not Chars
\framesubtitle{Compile patterns to byte-level automata, then iterate over bytes.}

- Problem :: Char-by-char varint decoding of multibyte\footnote{No worse than UTF-8 in general, but we may be able to pipeline decoding somehow.} is comparatively slow. @@latex:\vspace{4pt}@@
  - This is the reason go's "RE2" is much much slower than the C++ ~RE2~ library.\footnote{Source: a very dear friend.}
- Solution :: We can do this work at compile time instead!\footnote{This is already what we do for e.g. char-folding.}
  - Generates a larger automaton in order to be able to think in terms of byte ranges.\footnote{This is a necessary prerequisite for SIMD instructions.}

** Explicit Control over Linguistic Complexity
\framesubtitle{Break apart the monolithic regex pattern interface into subroutines for specific inputs.}

- Problem[1] :: There's no way to validate that a given pattern isn't more complex than expected.
  - This requires careful escaping to avoid accidentally triggering regex behavior.
- Problem[2] :: There's no way to ensure Emacs uses faster algorithms@@latex:\footnote{See \url{https://github.com/BurntSushi/rebar} for a fantastic discussion of techniques for regex performance.}@@ for less complex patterns.\footnote{We perform a heuristic check for literal patterns, but only in some code paths.}
  - This results in difficult-to-understand performance characteristics.
- Problem[3] :: There's no way to specify different search semantics.\footnote{Such as allowing false positives, or matching against a set of patterns.}
  - Instead, we have a single type of input and a single type of output.

** Explicit Control over Linguistic Complexity
\framesubtitle{Break apart the monolithic regex pattern interface into subroutines for specific inputs.}

- Solution[1] :: Single or multiple literals\footnote{Multiple literals is especially helpful for matching a set of keywords.} can employ specialized SIMD algorithms to avoid reading every single byte one by one.@@latex:\footnote{This is used as a "prefilter" optimization in modern engines like \texttt{RE2} to avoid reading each byte one-by-one.}@@
- Solution[2] :: Non-capturing patterns or patterns without backrefs@@latex:\footnote{These have recently been formalized: \url{https://jamiejennings.com/posts/2023-10-01-dont-look-back-3/}.}@@ can use faster automata.
- Solution[3] :: Collecting a sequence of matches for the same pattern can be done all at once.\footnote{Overlapping matches can be supported for ambiguous cases, instead of choosing longest or shortest only.}
- Solution[4] :: Matching against a set of patterns can be done more efficiently and ergonomically than combining with ~\|~.

** Lisp Regexp Library
\framesubtitle{Expose a lisp-level library for regexp matching.}

- Problem :: The compiled form of the regexp in ~re_pattern_buffer~ can be /executed/, but not really /introspected/.
  - No form of "IR": this also contributes to the difficulty of composing patterns together.
- Solution@@latex:\footnote{Proposed by Pip Cet on \texttt{emacs-devel}.}@@ :: We have ~libgccjit~ now: *why not implement the regex engine itself in lisp?\footnote{Alternatively, translate the regexp into lisp which we can then JIT.}*
- Results :: /(postulated)/:
  - Integration into ~pcase~ could achieve a form of type safety along with interleaving lisp-level matching logic.
  - Biggest issue for optimization: lisp code (or native modules) can't access or operate on the separate halves of the gap buffer.

* Do you have any concrete examples? Or are you just posturing?
** Answer
*** Do you have any concrete examples?
Yes!
*** Or are you just posturing?
My posture is terrible!@@latex:\footnote[frame]{Other translations have also been suggested by modern scholars, including \textit{formidable}, as well as \textit{awe-inspiring}.}@@

** @@latex:\texttt{helm-rg}\footnote{\url{https://github.com/cosmicexplorer/helm-rg}}@@
@@latex:\framesubtitle{A code search tool similar to \texttt{M-x grep}, using \texttt{ripgrep}\footnote{\url{https://blog.burntsushi.net/ripgrep/}}.}@@

*** A block                                           :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
- Generates regexps from input:
  - ~"a b"~ => ~"a.*b|b.*a"~.
  - Translates from PCRE to elisp regexps to highlight matches in the helm buffer.
- ~M-b~ enters "bounce mode", where matched lines can be edited directly.

*** pattern generation                                      :BMCOL:B_example:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :BEAMER_env: example
    :END:
#+ATTR_LaTeX: :width \textwidth
[[file:./emacs-helm-rg.png]]

** @@latex:\texttt{telepathygrams}\footnote{\url{https://github.com/cosmicexplorer/telepathygrams}}@@
\framesubtitle{A (WIP) code search tool that precompiles a database to execute NFAs against.}

I want to beat ~ripgrep~ by "cheating"\footnote{There are other ways to cheat here too, like precompiling known queries.} with a precompiled index.@@latex:\footnote{Inspired by \texttt{etags}, but with a more complex index for more general queries.} \vspace{4pt}@@
- n-gram indices have been done,@@latex:\footnote{e.g. Kythe: \url{https://kythe.io/docs/kythe-overview.html}}@@ but I don't want to just find where to /start/--I want to execute the /entire search/ against the index!
- This requires virtualizing NFA state so that it may be distributed:
  - across time :: in parallel / across machines,
  - & space :: in terms of /offsets/ vs directly against the input data.
- This may fail, but it will be fun!

** RIP @@latex:\texttt{@junyer}\footnote{\url{https://github.com/google/re2/issues/502}}@@
@@latex:\centering@@
*Paul Wankadia taught me everything.*

** ~(point-max)~
@@latex:\framesubtitle{\twemoji{microphone} call me beep me if you wanna reach me\footnote{or hire me}}@@

*** ~text-mode~
- fedi :: [[https://circumstances.run/@hipsterelectron][~@hipsterelectron@circumstances.run~]]@@latex:\footnote{also (sporadically) \href{https://twitter.com/hipsterelectron}{twitter} \& \href{https://bsky.app/profile/hipsterelectron.bsky.social}{bluesky}}@@
- IRC :: ~@cosmicexplorer~ in @@latex:\texttt{\#emacsconf}\footnote{also (sporadically) elsewhere}@@ on ~irc.libera.chat~
- email :: [[mailto:dmc2@hypnicjerk.ai][~dmc2@hypnicjerk.ai~]]@@latex:\footnote{also \texttt{dmcC2@} (still deciding which poetic license to use)}@@

*** ~prog-mode~
- codeberg :: [[https://codeberg.org/cosmicexplorer][~@cosmicexplorer~]]
- github :: [[https://github.com/cosmicexplorer][~@cosmicexplorer~]]
